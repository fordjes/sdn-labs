---
date: "2016-11-26"
draft: false
weight: 300
title: "Lab 14 - Introducing the Controllers (Ryu)"
---
[Click here to find out more about Alta3 Research's SDN Training](https://alta3.com/courses/sdn)

### WEDNESDAY - &#x2B50;REQUIRED&#x2B50;

### Lab Objective
The objective of this lab is to teach how to build an SDN controller using the Ryu library. Ryu can do more than just OpenFlow, but Ryu is an OpenFlow controller library. With it, we can make Ryu library calls that allow us to build an SDN OpenFlow controller. It may be worth reminding students that an SDN contoller is one that can recieve information about packets, and send flow mods / packets in response.

### Procedure

0. Okay, let's create a new file called, *base.py*. This file will teach Ryu how to build the *skeleton framework* of a controller. It will not be able to make any modifications to the network fabric, or any packet responses. The hope is that by evaluating this skeleton, we can see what ryu-manager provides us, "out of the box", without any code written / applied.

0. Ryu-manager runs ryu-applciations. Ryu-manager does the hardwork of receiving OpenFlow packets. We can write highly abstracted ryu-applciations to instruct ryu-manager on how to behave to the OpenFlow packets it is receiving. 

0. Copy and paste the following ryu-application (code) into a file called *base.py*

  ``` python
  # these import statements are the libraries required in order to access the functions we need
  from ryu.base import app_manager
  from ryu.controller import ofp_event
  from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
  from ryu.controller.handler import set_ev_cls
  from ryu.ofproto import ofproto_v1_3

  # create a class for our app manager called L2Switch
  # this means that ryu-manager will register this ryu-app
  class L2Switch(app_manager.RyuApp):

  # define the OpenFlow version this ryu-app will use
  OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

  # initialization incantation of this class (pass in args to self)
  # these next two lines ask calling function arguments to be passed to the initialization of our application (L2Switch) 
  def __init__(self, *args, **kwargs):
    super(L2Switch, self).__init__(*args, **kwargs)
  
  # The ryu-manager will do the hardwork of recieving OpenFlow packets
  # If one of those packets is a switch features interrogation, the EventOFPSwitchFeatures will be created
  # ryu-manger will call this function because it has been registered for the event EventOFPSwitchFeatures
  # Handle switch feature interrogation event 
  @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
  def switch_features_handler(self, ev):
    # The line below will have the ryu-app do nothing 
    return

  # Handle switch packet in event
  @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
  def packet_in_handler(self, ev):
     # The line below will have the ryu-app do nothing 
    return
  ```
  
0. This code reflects the bare minimum OpenFlow v1.3 ryu-application to allow ryu-manager controller to function. Without this code, ryu-manager would refuse to process OpenFlow packets (of any version). However, this code does **not** teach our switch to send unknown packets, by default, to the controller. This would be typical behavior in a properly functioning OpenFlow switch, and is handled by sending the switch a *Flow-Mod* packet. We **will not** see that packet in this capture. We will correct this issue in a future lab.

0. Startup wireshark and capture the packets which flow to/from the controller in this setup.

  Terminal1: `sudo wireshark &`
  
  Terminal2: `ryu-manager base.py`

  Terminal3: `sudo mn --controller=remote,ip=127.0.0.1,port=6653`

0. Answer the below questions about the wireshark capture:

  - **Q1: What openflow packets were sent / received from the controller?**
    - A1: ECHO, MULTIPART REQUEST (PORT DESC REQUEST), 
  - **Q2: As a result of seeing these of packets, what does the ryu manager automatically do for us without any code?**
    - A2:
  - **Q3: If we ran `pingall` inside mininet would we see a PacketIn message to the controller? Why or why not?**
    - A3:

0. Tear down

  * `mininet> exit`
  * quit wireshark
  * Ctrl+C from ryu-manager
